// Code generated by MockGen. DO NOT EDIT.
// Source: ./fixtures.go
//
// Generated by this command:
//
//	mockgen -typed -source ./fixtures.go -destination ./mocks.gen.go -package tinjectz
//

// Package tinjectz is a generated GoMock package.
package tinjectz

import (
	context "context"
	reflect "reflect"

	injectz "github.com/ibrt/golang-utils/injectz"
	gomock "go.uber.org/mock/gomock"
)

// MockInitializer is a mock of Initializer interface.
type MockInitializer struct {
	ctrl     *gomock.Controller
	recorder *MockInitializerMockRecorder
	isgomock struct{}
}

// MockInitializerMockRecorder is the mock recorder for MockInitializer.
type MockInitializerMockRecorder struct {
	mock *MockInitializer
}

// NewMockInitializer creates a new mock instance.
func NewMockInitializer(ctrl *gomock.Controller) *MockInitializer {
	mock := &MockInitializer{ctrl: ctrl}
	mock.recorder = &MockInitializerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInitializer) EXPECT() *MockInitializerMockRecorder {
	return m.recorder
}

// Initialize mocks base method.
func (m *MockInitializer) Initialize(ctx context.Context) (injectz.Injector, injectz.Releaser) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Initialize", ctx)
	ret0, _ := ret[0].(injectz.Injector)
	ret1, _ := ret[1].(injectz.Releaser)
	return ret0, ret1
}

// Initialize indicates an expected call of Initialize.
func (mr *MockInitializerMockRecorder) Initialize(ctx any) *MockInitializerInitializeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Initialize", reflect.TypeOf((*MockInitializer)(nil).Initialize), ctx)
	return &MockInitializerInitializeCall{Call: call}
}

// MockInitializerInitializeCall wrap *gomock.Call
type MockInitializerInitializeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInitializerInitializeCall) Return(arg0 injectz.Injector, arg1 injectz.Releaser) *MockInitializerInitializeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInitializerInitializeCall) Do(f func(context.Context) (injectz.Injector, injectz.Releaser)) *MockInitializerInitializeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInitializerInitializeCall) DoAndReturn(f func(context.Context) (injectz.Injector, injectz.Releaser)) *MockInitializerInitializeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockInjector is a mock of Injector interface.
type MockInjector struct {
	ctrl     *gomock.Controller
	recorder *MockInjectorMockRecorder
	isgomock struct{}
}

// MockInjectorMockRecorder is the mock recorder for MockInjector.
type MockInjectorMockRecorder struct {
	mock *MockInjector
}

// NewMockInjector creates a new mock instance.
func NewMockInjector(ctrl *gomock.Controller) *MockInjector {
	mock := &MockInjector{ctrl: ctrl}
	mock.recorder = &MockInjectorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInjector) EXPECT() *MockInjectorMockRecorder {
	return m.recorder
}

// Inject mocks base method.
func (m *MockInjector) Inject(ctx context.Context) context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Inject", ctx)
	ret0, _ := ret[0].(context.Context)
	return ret0
}

// Inject indicates an expected call of Inject.
func (mr *MockInjectorMockRecorder) Inject(ctx any) *MockInjectorInjectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Inject", reflect.TypeOf((*MockInjector)(nil).Inject), ctx)
	return &MockInjectorInjectCall{Call: call}
}

// MockInjectorInjectCall wrap *gomock.Call
type MockInjectorInjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInjectorInjectCall) Return(arg0 context.Context) *MockInjectorInjectCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInjectorInjectCall) Do(f func(context.Context) context.Context) *MockInjectorInjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInjectorInjectCall) DoAndReturn(f func(context.Context) context.Context) *MockInjectorInjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockReleaser is a mock of Releaser interface.
type MockReleaser struct {
	ctrl     *gomock.Controller
	recorder *MockReleaserMockRecorder
	isgomock struct{}
}

// MockReleaserMockRecorder is the mock recorder for MockReleaser.
type MockReleaserMockRecorder struct {
	mock *MockReleaser
}

// NewMockReleaser creates a new mock instance.
func NewMockReleaser(ctrl *gomock.Controller) *MockReleaser {
	mock := &MockReleaser{ctrl: ctrl}
	mock.recorder = &MockReleaserMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReleaser) EXPECT() *MockReleaserMockRecorder {
	return m.recorder
}

// Release mocks base method.
func (m *MockReleaser) Release() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Release")
}

// Release indicates an expected call of Release.
func (mr *MockReleaserMockRecorder) Release() *MockReleaserReleaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockReleaser)(nil).Release))
	return &MockReleaserReleaseCall{Call: call}
}

// MockReleaserReleaseCall wrap *gomock.Call
type MockReleaserReleaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReleaserReleaseCall) Return() *MockReleaserReleaseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReleaserReleaseCall) Do(f func()) *MockReleaserReleaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReleaserReleaseCall) DoAndReturn(f func()) *MockReleaserReleaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCloser is a mock of Closer interface.
type MockCloser struct {
	ctrl     *gomock.Controller
	recorder *MockCloserMockRecorder
	isgomock struct{}
}

// MockCloserMockRecorder is the mock recorder for MockCloser.
type MockCloserMockRecorder struct {
	mock *MockCloser
}

// NewMockCloser creates a new mock instance.
func NewMockCloser(ctrl *gomock.Controller) *MockCloser {
	mock := &MockCloser{ctrl: ctrl}
	mock.recorder = &MockCloserMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCloser) EXPECT() *MockCloserMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockCloser) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockCloserMockRecorder) Close() *MockCloserCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockCloser)(nil).Close))
	return &MockCloserCloseCall{Call: call}
}

// MockCloserCloseCall wrap *gomock.Call
type MockCloserCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCloserCloseCall) Return(arg0 error) *MockCloserCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCloserCloseCall) Do(f func() error) *MockCloserCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCloserCloseCall) DoAndReturn(f func() error) *MockCloserCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
