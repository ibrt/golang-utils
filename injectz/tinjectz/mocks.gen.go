// Code generated by MockGen. DO NOT EDIT.
// Source: ./fixtures.go
//
// Generated by this command:
//
//	mockgen -typed -write_package_comment=false -source ./fixtures.go -destination ./mocks.gen.go -package tinjectz
//

package tinjectz

import (
	context "context"
	reflect "reflect"

	injectz "github.com/ibrt/golang-utils/injectz"
	gomock "go.uber.org/mock/gomock"
)

// MockTestInitializer is a mock of TestInitializer interface.
type MockTestInitializer struct {
	ctrl     *gomock.Controller
	recorder *MockTestInitializerMockRecorder
	isgomock struct{}
}

// MockTestInitializerMockRecorder is the mock recorder for MockTestInitializer.
type MockTestInitializerMockRecorder struct {
	mock *MockTestInitializer
}

// NewMockTestInitializer creates a new mock instance.
func NewMockTestInitializer(ctrl *gomock.Controller) *MockTestInitializer {
	mock := &MockTestInitializer{ctrl: ctrl}
	mock.recorder = &MockTestInitializerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTestInitializer) EXPECT() *MockTestInitializerMockRecorder {
	return m.recorder
}

// Initialize mocks base method.
func (m *MockTestInitializer) Initialize(ctx context.Context) (injectz.Injector, injectz.Releaser) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Initialize", ctx)
	ret0, _ := ret[0].(injectz.Injector)
	ret1, _ := ret[1].(injectz.Releaser)
	return ret0, ret1
}

// Initialize indicates an expected call of Initialize.
func (mr *MockTestInitializerMockRecorder) Initialize(ctx any) *MockTestInitializerInitializeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Initialize", reflect.TypeOf((*MockTestInitializer)(nil).Initialize), ctx)
	return &MockTestInitializerInitializeCall{Call: call}
}

// MockTestInitializerInitializeCall wrap *gomock.Call
type MockTestInitializerInitializeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTestInitializerInitializeCall) Return(arg0 injectz.Injector, arg1 injectz.Releaser) *MockTestInitializerInitializeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTestInitializerInitializeCall) Do(f func(context.Context) (injectz.Injector, injectz.Releaser)) *MockTestInitializerInitializeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTestInitializerInitializeCall) DoAndReturn(f func(context.Context) (injectz.Injector, injectz.Releaser)) *MockTestInitializerInitializeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockTestInjector is a mock of TestInjector interface.
type MockTestInjector struct {
	ctrl     *gomock.Controller
	recorder *MockTestInjectorMockRecorder
	isgomock struct{}
}

// MockTestInjectorMockRecorder is the mock recorder for MockTestInjector.
type MockTestInjectorMockRecorder struct {
	mock *MockTestInjector
}

// NewMockTestInjector creates a new mock instance.
func NewMockTestInjector(ctrl *gomock.Controller) *MockTestInjector {
	mock := &MockTestInjector{ctrl: ctrl}
	mock.recorder = &MockTestInjectorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTestInjector) EXPECT() *MockTestInjectorMockRecorder {
	return m.recorder
}

// Inject mocks base method.
func (m *MockTestInjector) Inject(ctx context.Context) context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Inject", ctx)
	ret0, _ := ret[0].(context.Context)
	return ret0
}

// Inject indicates an expected call of Inject.
func (mr *MockTestInjectorMockRecorder) Inject(ctx any) *MockTestInjectorInjectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Inject", reflect.TypeOf((*MockTestInjector)(nil).Inject), ctx)
	return &MockTestInjectorInjectCall{Call: call}
}

// MockTestInjectorInjectCall wrap *gomock.Call
type MockTestInjectorInjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTestInjectorInjectCall) Return(arg0 context.Context) *MockTestInjectorInjectCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTestInjectorInjectCall) Do(f func(context.Context) context.Context) *MockTestInjectorInjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTestInjectorInjectCall) DoAndReturn(f func(context.Context) context.Context) *MockTestInjectorInjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockTestReleaser is a mock of TestReleaser interface.
type MockTestReleaser struct {
	ctrl     *gomock.Controller
	recorder *MockTestReleaserMockRecorder
	isgomock struct{}
}

// MockTestReleaserMockRecorder is the mock recorder for MockTestReleaser.
type MockTestReleaserMockRecorder struct {
	mock *MockTestReleaser
}

// NewMockTestReleaser creates a new mock instance.
func NewMockTestReleaser(ctrl *gomock.Controller) *MockTestReleaser {
	mock := &MockTestReleaser{ctrl: ctrl}
	mock.recorder = &MockTestReleaserMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTestReleaser) EXPECT() *MockTestReleaserMockRecorder {
	return m.recorder
}

// Release mocks base method.
func (m *MockTestReleaser) Release() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Release")
}

// Release indicates an expected call of Release.
func (mr *MockTestReleaserMockRecorder) Release() *MockTestReleaserReleaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockTestReleaser)(nil).Release))
	return &MockTestReleaserReleaseCall{Call: call}
}

// MockTestReleaserReleaseCall wrap *gomock.Call
type MockTestReleaserReleaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTestReleaserReleaseCall) Return() *MockTestReleaserReleaseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTestReleaserReleaseCall) Do(f func()) *MockTestReleaserReleaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTestReleaserReleaseCall) DoAndReturn(f func()) *MockTestReleaserReleaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
